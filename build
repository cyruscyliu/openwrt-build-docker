#!/usr/bin/python
import os
import hashlib
import argparse
from pyquery import PyQuery as pq
from autobots_build import make_build_package, \
    make_compile_docker, do_the_building


def find_version_in_url(url):
    items = url.split('/')

    version = items[4]
    if version in ['firmware', 'targets']:
        return None
    if version in [
            '0.9', '1.1', '7.06', '7.07', '7.09',
            '8.09', '8.09.1', '8.09.2', 'trunk']:
        return None

    return version


def find_versions():
    versions = []

    header = None
    with open('id_urls.csv') as f:
        for line in f:
            items = line.strip().split(',')
            if header is None:
                header = items
                continue
            url = items[header.index('url')]
            openwrtver = find_version_in_url(url)
            if openwrtver is not None and openwrtver not in versions:
                versions.append(openwrtver)
    return sorted(versions)


def find_target_in_url(url):
    homepage = os.path.dirname(url)

    items = homepage.split('/')
    if len(items) < 6:
        return None
    target = items[5]
    subtarget = None
    if len(items) >= 7:
        subtarget = items[6]

    if target in ['targets']:
        target = subtarget

    return target


def find_targets():
    targets = []

    header = None
    with open('id_urls.csv') as f:
        for line in f:
            items = line.strip().split(',')
            if header is None:
                header = items
                continue
            url = items[header.index('url')]
            target = find_target_in_url(url)
            if target is not None and target not in targets:
                targets.append(target)
    return sorted(targets)


def find_urls_in_openwrt_homepage(homepage):
    """
    The url for ImageBuilder must include "ImageBuilder".
    The url for config includes, OpenWrt.config(10.03), config.diff(15.05).
    """
    html = pq(url=homepage)
    a = html('a')
    image_builder = None
    dot_config = None
    for item in a.items():
        href = item.attr('href')
        if image_builder is None and href.lower().find('imagebuilder') != -1:
            image_builder = os.path.join(homepage, href)
        if dot_config is None and (href.find('config.diff') != -1 or href.find('OpenWrt.config') != -1):
            dot_config = os.path.join(homepage, href)
    return image_builder, dot_config


def build_hash_of_url_to_image_builder(targets=None, versions=None):
    header = None

    # read from image.builder.cache
    cache_image_builder_table = {}
    with open('image_builder.cache') as f:
        for line in f:
            things = line.strip().split(',')
            cache_image_builder_table[things[1]] = things[2]
    update_image_builder_table = []

    image_builder_table = {}
    with open('id_urls.csv') as f:
        for line in f:
            items = line.strip().split(',')
            if header is None:
                header = items
                continue
            uuid = items[header.index('id')]
            url = items[header.index('url')]
            openwrtver = find_version_in_url(url)
            # skip unneeded ones
            if versions is not None and openwrtver not in versions:
                continue
            target = find_target_in_url(url)
            if targets is not None and target not in targets:
                continue
            # find the image builder
            homepage = os.path.dirname(url)
            print('\tfind image builder in {}'.format(homepage))
            if homepage in cache_image_builder_table:
                url_to_image_builder = cache_image_builder_table[homepage]
            else:
                url_to_image_builder, _ = find_urls_in_openwrt_homepage(homepage)
                cache_image_builder_table[homepage] = url_to_image_builder
                update_image_builder_table.append(homepage)
            if url_to_image_builder is None:
                print('cannot find the image builder in {}, skip it'.format(homepage))
                continue
            # update the image_builder_table
            hash_of_image_builder = hashlib.md5(url_to_image_builder.encode('utf-8'))
            if hash_of_image_builder.hexdigest() in image_builder_table:
                # we also found many firmware share the same ImageBuilder
                # because they are downloaded from the same page
                image_builder_table[hash_of_image_builder.hexdigest()]['support'].append(uuid)
            else:
                image_builder_table[hash_of_image_builder.hexdigest()] = \
                    {'homepage': homepage, 'url': url_to_image_builder, 'support': [uuid]}

    # update image_builder.cache
    with open('image_builder.cache', 'a') as f:
        for k, v in image_builder_table.items():
            if v['homepage'] in update_image_builder_table:
                f.write('{},{},{},{}\n'.format(k, v['homepage'], v['url'], ','.join(v['support'])))

    return image_builder_table


def summary_makeout(build_dir):
    makeout = os.popen('cd {} && find -name makeout.txt'.format(build_dir)).readlines()
    if len(makeout):
        return os.path.join(build_dir, makeout[0].strip())
    return None


def summary_source_code(build_dir):
    # find vmlinux.elf-debug-info
    vmlinux_debug_results = os.popen(
        'cd {} && find -name vmlinux.elf-debug-info'.format(build_dir)).readlines()
    set_vmlinux_debug = set([os.path.dirname(path) for path in vmlinux_debug_results])
    # find vmlinux
    vmlinux_results = os.popen(
        'cd {} && find -name vmlinux'.format(build_dir)).readlines()
    set_vmlinux = set([os.path.dirname(os.path.dirname(path)) for path in vmlinux_results])
    target_dirs = set_vmlinux_debug & set_vmlinux
    if not len(target_dirs):
        return None
    # find .config
    dot_config_results = os.popen(
        'cd {} && find -name .config'.format(build_dir)).readlines()
    set_config = set([os.path.dirname(os.path.dirname(path)) for path in dot_config_results])
    target_dirs = target_dirs & set_config
    if not len(target_dirs):
        return None
    # fill in support list
    target_dir = list(target_dirs)[0]
    # vmlinux.elf-debug-info
    for path in vmlinux_debug_results:
        if os.path.dirname(path) == target_dir:
            path_to_vmlinux_debug_info = os.path.join(build_dir, path.strip())
    # source code
    for path in vmlinux_results:
        if os.path.dirname(os.path.dirname(path)) == target_dir and os.path.basename(
                os.path.dirname(path)).find('linux') != -1:
            path_to_source_code = os.path.join(build_dir, os.path.dirname(path.strip()))
            path_to_vmlinux = os.path.join(build_dir, path.strip())
            path_to_dot_config = os.path.join(build_dir, os.path.join(os.path.dirname(path.strip()), '.config'))
    return [path_to_vmlinux_debug_info, path_to_source_code, path_to_vmlinux, path_to_dot_config]


def summary_by_uuid(uuid, openwrt_ver, hash_of_image_builder):
    summary = os.path.join('summary', '{}.summary'.format(uuid))
    if os.path.exists(summary):
        print('\tsummary at summary/{}.summary'.format(uuid))
        return None

    info = [uuid, hash_of_image_builder, '', '']
    # 0/1/2/3

    build_dir = "share/{}-{}".format(openwrt_ver, hash_of_image_builder)
    info.append(build_dir)
    # 4

    source_code = summary_source_code(build_dir)
    if source_code is None:
        print('fail to summarize source code')
        return None
    info.extend(source_code)
    # 5/6/7/8

    makeout = summary_makeout(build_dir)
    if makeout is None:
        print('fail to summarize makeout.txt')
        return None
    info.append(makeout)
    # 9

    gcc_results = os.popen(
        'cd {} && find -name *-openwrt-linux-gcc'.format(build_dir)).readlines()
    if len(gcc_results):
        path_to_gcc = os.path.join(build_dir, gcc_results[0].strip())
        info.append(path_to_gcc)
    else:
        info.append('')
    # 10

    # binary = os.path.basename(url)
    # binary_results = os.popen(
    #     'cd {} && find -name {}'.format(build_dir, binary)).readlines()
    # if len(binary_results):
    #     path_to_binary = os.path.join(build_dir, binary_results[0].strip())
    #     info.append(path_to_binary)
    # else:
    #     info.append('')
    info.append('')
    # 11

    with open('summary/{}.summary'.format(uuid), 'w') as f:
        f.write(','.join(info))
    print('\tsummary at summary/{}.summary'.format(uuid))


def summary():
    # read from image.builder.cache
    image_builder_table = {}
    with open('image_builder.cache') as f:
        for line in f:
            things = line.strip().split(',')
            image_builder_table[things[0]] = {'url': things[2], 'support': things[3:]}

    for k, v in image_builder_table.items():
        for uuid in v['support']:
            openwrt_ver = find_version_in_url(v['url'])
            summary_by_uuid(uuid, openwrt_ver, k)


def download_image_builder(url):
    """Download the image builder to ./share."""
    image_builder_name = \
        os.path.basename(url.replace('.tar.bz2', '').replace('.tar.xz', ''))
    config = os.path.join('share', image_builder_name, '.config')

    if os.path.exists(config):
        return config

    # we don't trust the downloaded image builder which is maybe not complete
    os.system('wget -nc {} -P share'.format(url))
    if url.endswith('.tar.bz2'):
        os.system('cd share && tar jxvf {0}.tar.bz2 {0}/.config >/dev/null 2>&1'.format(image_builder_name))
    elif url.endswith('.tar.xz'):
        os.system('cd share && tar Jxvf {0}.tar.xz {0}/.config >/dev/null 2>&1'.format(image_builder_name))
    return config


def build(targets, versions, update_only=False, really_build=False):
    image_builder_table = \
        build_hash_of_url_to_image_builder(targets, versions)
    if update_only:
        return None

    for k, v in image_builder_table.items():
        print('\t' + v['url'])

        # use autobots interface
        openwrt_ver = v['url'].split('/')[4]
        compile_script = make_compile_docker(openwrt_ver)

        target_dir = 'share'
        config_path = download_image_builder(v['url'])
        build_dir = make_build_package(target_dir, openwrt_ver, config_path, tag=k)
        print('\t', build_dir)
        if really_build:
            do_the_building(build_dir, compile_script)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-s', '--summary', action='store_true', default=False,
                                          help='summary all')
    parser.add_argument('-t', '--targets', nargs='*', help=','.join(find_versions()))
    parser.add_argument('-v', '--versions', nargs='*', help=','.join(find_targets()))
    parser.add_argument('-uo', '--update_only', action='store_true', default=False,
                                          help='update the image builder cache only')
    parser.add_argument('-rb', '--really_build', action='store_true', default=False,
                                          help='really build the openwrt project')
    args = parser.parse_args()

    if args.summary:
        summary()
    else:
        build(args.targets, args.versions, update_only=args.update_only, really_build=args.really_build)

